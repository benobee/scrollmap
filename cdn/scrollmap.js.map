{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../src/scrollmap.js","webpack:///../src/trigger.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Scrollmap","Scroll_Event_Trigger","_classCallCheck","this","lastScrollTop","points","topics","topic","data","length","forEach","listener","push","array","options","func","Array","slice","delay","order","sequenceOrder","run","item","setTimeout","interval","sort","Math","random","reverse","args","callback","_this","el","target","triggerElementSelector","triggerElement","checkSelector","node","setAttribute","Date","now","toString","substr","_id","transition","point","Trigger","_typeof","toArray","document","querySelectorAll","collection","element","isVisible","hasBeenVisible","alwaysRunOnTrigger","onTriggerIn","runOnScroll","percetageOfElement","rect","getBoundingClientRect","stats","top","window","innerHeight","bottom","height","amount","elementInViewport","surfaceVisible","setTriggerIn","setTriggerOut","direction","st","pageYOffset","documentElement","scrollTop","_this2","addEventListener","checkVisible","scrollOrient","scrollDirection","emit","trigger","index","indexOf","splice","bindEventListeners","_extends","isDestroyed"],"mappings":"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","file":"scrollmap.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import Trigger from \"./trigger\";\r\n\r\n/**\r\n * A module for testing if a DOM element is visible in the\r\n * viewport, then triggers callbacks on execution.\r\n * @namespace ScrollMap\r\n */\r\n\r\nclass Scroll_Event_Trigger {\r\n    constructor () {\r\n        this.lastScrollTop = 0;\r\n        this.points = [];\r\n        this.topics = {};\r\n    }\r\n\r\n    /**\r\n     * Publish method of the pubsub pattern.\r\n     * @param  {String} topic\r\n     * @param  {Object} data\r\n     */\r\n    emit (topic, data) {\r\n        // return if the topic doesn't exist, or there are no listeners\r\n        if (!this.topics[ topic ] || this.topics[ topic ].length < 1) {\r\n            return;\r\n        }\r\n\r\n        // send the event to all listeners\r\n        this.topics[ topic ].forEach((listener) => listener(data || {}));\r\n    }\r\n\r\n    /**\r\n     * Subscribe method of pubsub pattern\r\n     * @param  {String} topic\r\n     * @param  {Function} listener\r\n     */\r\n    on (topic, listener) {\r\n        // create the topic if not yet created\r\n        if (!this.topics[ topic ]) {\r\n            this.topics[ topic ] = [];\r\n        }\r\n\r\n        // add the listener\r\n        this.topics[ topic ].push(listener);\r\n    }\r\n\r\n    /**\r\n     * A method for staggering an array of triggers.\r\n     *\r\n     * Properties for options config object:\r\n     *\r\n     * interval: (number) :\r\n     * changes the interval speed of the sequence\r\n     *\r\n     * order: (string) :\r\n     * changes the order of the sequence. Order options are \"random\", and \"reverse\".\r\n     *\r\n     * callback (item, index):\r\n     * can get the item and index of the array as arguments\r\n     *\r\n     * @param  {Array} array\r\n     * @param  {Object} options\r\n     * @param  {Function} func\r\n     * @memberOf Scrollmap\r\n     * @return {Object}\r\n     */\r\n\r\n    sequence (array, options, func) {\r\n        array = Array.prototype.slice.call(array);\r\n\r\n        let delay = 0;\r\n\r\n        if (options.order) {\r\n            this.sequenceOrder(array, options.order);\r\n        }\r\n\r\n        if (options.delay) {\r\n            delay = options.delay;\r\n        }\r\n\r\n        const run = array.forEach((item, i) => {\r\n            setTimeout(() => {\r\n                func(array[ i ], i);\r\n            }, options.interval * i);\r\n        });\r\n\r\n        setTimeout(run, delay);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * The method which executes the the desired\r\n     * sequence method based on the arguments\r\n     * @param  {Array} array\r\n     * @param  {String} order\r\n     * @memberOf Scrollmap\r\n     * @return {Array}\r\n     */\r\n\r\n    sequenceOrder (array, order) {\r\n        switch (order) {\r\n            case \"random\":\r\n                array = array.sort(() => {\r\n                    return 0.5 - Math.random();\r\n                });\r\n                break;\r\n            case \"reverse\":\r\n                array = array.reverse();\r\n                break;\r\n            default:\r\n        }\r\n        return array;\r\n    }\r\n\r\n    /**\r\n     * A method for adding triggers when element is visible in the viewport.\r\n     *\r\n     * Properties for options config object:\r\n     * target (string or element): Using querySelectorAll a target string selector\r\n     * is needed, or you can specify an actual element.\r\n     *\r\n     * surfaceVisible (number): the percentage area, which is represented as a\r\n     * number from 0 - 1 is the area of the which is visible in the viewport.\r\n     *\r\n     * runOnScroll (boolean) : by default the callback is run only one time whent\r\n     * the element is visible. By changing to true, the callback will be run\r\n     * as long as the scroll event is happening.\r\n     *\r\n     * alwaysRunOnTrigger (boolean): by default the triggered element callback\r\n     * will only be executed one time. Setting to true will re-trigger thcallback\r\n     * everytime the element has been in and out of the viewport.\r\n     *\r\n     * callback (object):\r\n     * This is the function which will be exectued when the element is detected\r\n     * in the viewport. To reference the node, pass it into the callback as an argument.\r\n     *\r\n     * @param  {Object}   args     options for callback triggering\r\n     * @param  {Function} callback the method executed based on the argments\r\n     * @memberOf Scrollmap\r\n     */\r\n\r\n    trigger (args, callback) {\r\n        let el = args.target;\r\n        let triggerElementSelector = args.triggerElement;\r\n\r\n        if (triggerElementSelector) {\r\n            triggerElementSelector = this.checkSelector(triggerElementSelector);\r\n        }\r\n\r\n        el = this.checkSelector(el);\r\n\r\n        const _id = (i) => {\r\n            return `_${Date.now().toString(36) + Math.random().toString(36).substr(2, 5)}_${i}`;\r\n        };\r\n\r\n        el.forEach((node, i) => {\r\n            node.setAttribute(\"data-scrollmap-id\", _id(i));\r\n            if (triggerElementSelector) {\r\n                node.setAttribute(\"data-scrollmap-trigger-element\", triggerElementSelector);\r\n            }\r\n            if (args.transition) {\r\n                node.setAttribute(\"data-scrollmap-transition\", args.transition);\r\n            }\r\n            node.setAttribute(\"data-scrollmap-loaded\", true);\r\n            node.setAttribute(\"data-scrollmap-triggered-in\", false);\r\n            node.setAttribute(\"data-scrollmap-triggered-out\", false);\r\n            const point = new Trigger(node, args, callback);\r\n\r\n            this.points.push(point);\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * The target element can either be a string query selector\r\n     * or a DOM element. This determines which method is being\r\n     * used and retuns the element into an array.\r\n     *\r\n     * @param  {String, HTMLElement} target the desired target DOM element.\r\n     * @return {Array}\r\n     * @memberOf Scrollmap\r\n     */\r\n\r\n    checkSelector (target) {\r\n        switch (typeof target) {\r\n            case \"string\":\r\n                target = this.toArray(document.querySelectorAll(target));\r\n                break;\r\n            case \"object\":\r\n                target = [target];\r\n                break;\r\n            default:\r\n                target = this.toArray(document.querySelectorAll(target));\r\n        }\r\n\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     * creates a true array from collection of elements\r\n     * @param  {HTMLElement} collection\r\n     * @memberOf Scrollmap\r\n     * @return {Array}            returns the converted node list.\r\n     */\r\n\r\n    toArray (collection) {\r\n        return Array.prototype.slice.call(collection);\r\n    }\r\n\r\n    /**\r\n     * sets points with data hooks and runs callback method\r\n     * @memberOf Scrollmap\r\n     * @param {Object} point\r\n     */\r\n\r\n    setTriggerIn (point) {\r\n        point.element.setAttribute(\"data-scrollmap-is-visible\", true);\r\n        point.element.setAttribute(\"data-scrollmap-triggered-in\", true);\r\n        if (!point.isVisible && !point.hasBeenVisible) {\r\n            if (point.callback) {\r\n                if (!point.alwaysRunOnTrigger) {\r\n                    point.hasBeenVisible = true;\r\n                }\r\n                point.onTriggerIn();\r\n            }\r\n            if (!point.runOnScroll) {\r\n                point.isVisible = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attaches various data attributes to the initailized\r\n     * DOM element. This is useful for doing CSS hooks.\r\n     * @param {Object} point the point in the index to be mututated.\r\n     * @memberOf Scrollmap\r\n     */\r\n\r\n    setTriggerOut (point) {\r\n        point.element.setAttribute(\"data-scrollmap-is-visible\", false);\r\n        point.element.setAttribute(\"data-scrollmap-triggered-out\", true);\r\n        point.isVisible = false;\r\n        if (point.alwaysRunOnTrigger) {\r\n            point.element.setAttribute(\"data-scrollmap-triggered-in\", false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * look for direction of scroll and base element visible\r\n     * percentage off of either top bottom when scrolling\r\n     * down, or the top when scrolling up.\r\n     *\r\n     * @param  {DOM} el                 the trigger element\r\n     * @param  {Number} percetageOfElement the option value for percent of element viewable in the viewport\r\n     * @return {Bool}                    if element is not in the viewport we return false\r\n     * @memberOf Scrollmap\r\n     */\r\n\r\n    elementInViewport (el, percetageOfElement) {\r\n        const rect = el.getBoundingClientRect();\r\n        const stats = {\r\n            top: rect.top - window.innerHeight,\r\n            bottom: rect.bottom + rect.height,\r\n            height: rect.height\r\n        };\r\n        const amount = stats.height * percetageOfElement;\r\n\r\n        if ((stats.bottom - amount > stats.height) && (stats.top + amount < 0)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Created a separate method for readability in what\r\n     * happens after the element in in the viewport.\r\n     *\r\n     * @param  {[type]} point [description]\r\n     * @returns {[type]}       [description]\r\n     * @memberOf Scrollmap\r\n     */\r\n    checkVisible (point) {\r\n        const elementInviewport = this.elementInViewport(point.element, point.surfaceVisible);\r\n\r\n        if (elementInviewport) {\r\n            this.setTriggerIn(point);\r\n        } else {\r\n            this.setTriggerOut(point);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * return the scroll direction via a string value\r\n     * @return {String}\r\n     * @memberOf Scrollmap\r\n     */\r\n\r\n    scrollDirection () {\r\n        let direction = \"\";\r\n        const st = window.pageYOffset || document.documentElement.scrollTop;\r\n\r\n        if (st > this.lastScrollTop) {\r\n            direction = \"scrollDown\";\r\n        } else {\r\n            direction = \"scrollUp\";\r\n        }\r\n        this.lastScrollTop = st;\r\n\r\n        return direction;\r\n    }\r\n\r\n    /**\r\n     * bind event listeners to to enable the execution\r\n     * of all desired functions.\r\n     */\r\n\r\n    bindEventListeners () {\r\n        // initial check on page load to see if elements are visible\r\n        window.addEventListener(\"load\", () => {\r\n            this.points.forEach((point) => {\r\n                this.checkVisible(point);\r\n            });\r\n        }, false);\r\n\r\n        // check for visible elements on scroll\r\n        window.addEventListener(\"scroll\", () => {\r\n            this.scrollOrient = this.scrollDirection();\r\n            this.emit(this.scrollOrient);\r\n            this.points.forEach((point) => {\r\n                this.checkVisible(point);\r\n            });\r\n        });\r\n    }\r\n\r\n    remove (trigger) {\r\n        const index = this.points.indexOf(trigger);\r\n\r\n        if (index > -1) {\r\n            this.points.splice(index, 1);\r\n        }\r\n    }\r\n}\r\n\r\nconst Scrollmap = new Scroll_Event_Trigger();\r\n\r\nScrollmap.bindEventListeners();\r\n\r\nwindow.Scrollmap = Scrollmap;\r\n\r\nexport default Scrollmap;","class Trigger {\r\n\tconstructor (element, options, callback) {\r\n\t\tthis.element = element; // the DOM node to trigger\r\n\t\tthis.callback = callback; // function to execute on visible\r\n\t\tthis.isVisible = false; // is visible in the viewport\r\n\t\tthis.hasBeenVisible = false; // has been in and out of the viewport\r\n\t\tthis.surfaceVisible = 0.5; // the area of the element that will trigger the callback \"default is 50%\"\r\n\t\tthis.runOnScroll = false; // for setting the callback to execute when the element is visible\r\n\t\tthis.delay = 0;\r\n\t\tthis.alwaysRunOnTrigger = false; // toggle to always execute the callback after element has been visible.\r\n\r\n\t\tif (options) {\r\n\t\t\tObject.assign(this, options);\r\n\t\t}\r\n\t}\r\n\tonTriggerIn () {\r\n\t\tif (this.triggerElement) {\r\n\t\t\tthis.triggerElement.forEach((node) => {\r\n\t\t\t\tif (this.transition) {\r\n\t\t\t\t\tnode.setAttribute(\"data-scrollmap-transition\", this.transition);\r\n\t\t\t\t}\r\n\t\t\t\tthis.callback(node);\r\n\t\t\t});\r\n\t\t}\r\n\t\tthis.callback(this.element);\r\n\r\n\t\treturn this;\r\n\t}\r\n\tdestroy () {\r\n\t\tthis.element = null;\r\n\t\tthis.isDestroyed = true;\r\n\t}\r\n}\r\n\r\nexport default Trigger;"],"sourceRoot":""}